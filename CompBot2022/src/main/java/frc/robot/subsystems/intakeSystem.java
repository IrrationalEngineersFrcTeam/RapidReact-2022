// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

 
import frc.robot.Constants;
import frc.robot.commands.*; 
import edu.wpi.first.wpilibj.livewindow.LiveWindow; 
import edu.wpi.first.wpilibj2.command.SubsystemBase; 
 
// Add imports for WPI_TalonFX FX motors 
import com.ctre.phoenix.motorcontrol.ControlMode; 
import com.ctre.phoenix.motorcontrol.InvertType; 
import com.ctre.phoenix.motorcontrol.TalonFXInvertType; 
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX; 
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS 
import edu.wpi.first.wpilibj.motorcontrol.MotorController; 
import edu.wpi.first.wpilibj.motorcontrol.Talon;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
import com.ctre.phoenix.motorcontrol.*;
import com.ctre.phoenix.motorcontrol.ControlMode;
 
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS 
 
 
/** 
 * 
 */ 
public class intakeSystem extends SubsystemBase { 
    private double intakeMotorPosition;
    private WPI_TalonFX m_lowerIntakeMotor; 
    private CANSparkMax m_intakeWheelMotor;
    private boolean inverted = true;
    private boolean intakeMotorRunning;
    final int kUnitsPerRevolution = 2048;
    final TalonFXInvertType kInvertType = TalonFXInvertType.Clockwise;
    final NeutralMode kBrakeDurNeutral = NeutralMode.Coast;
    // Used to indicate when intake is lowered all the way
    private boolean intakeLowered = false;
    // Used to indicate when intake starts lowering
    private boolean intakeLowering = false;
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS 
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS 
 
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS 
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS 
     
    /** 
    * 
    */ 
    public intakeSystem() { 
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS 
        m_lowerIntakeMotor = new WPI_TalonFX(Constants.IntakeConstants.kIntakeLowerMotorPort);
        addChild("m_intake",m_lowerIntakeMotor); 

        TalonFXConfiguration configs = new TalonFXConfiguration();
        configs.primaryPID.selectedFeedbackSensor = FeedbackDevice.IntegratedSensor;
        m_lowerIntakeMotor.configAllSettings(configs);
        m_lowerIntakeMotor.configFactoryDefault();
        m_lowerIntakeMotor.configClearPositionOnLimitR(true, 20);
        m_lowerIntakeMotor.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen, 20);

        m_lowerIntakeMotor.set(ControlMode.PercentOutput, 0.0);
        intakeMotorRunning = false;
        m_lowerIntakeMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_2_Feedback0, 20);
        m_lowerIntakeMotor.setInverted(kInvertType);
        m_lowerIntakeMotor.setNeutralMode(kBrakeDurNeutral);
        
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS 
        m_intakeWheelMotor = new CANSparkMax(Constants.IntakeConstants.kIntakeWheelMotorPort, MotorType.kBrushless);
        m_intakeWheelMotor.restoreFactoryDefaults();

    } 
 
    @Override 
    public void periodic() { 
        // This method will be called once per scheduler run 
    } 

    // This is called at the end to reset state of the intake
    public void resetIntakeState() {
        intakeLowered = false;
    }

    public void startMotor() {
        m_intakeWheelMotor.set(Constants.IntakeConstants.intakeWheelSpeed);
        intakeMotorRunning = true;
    }

    public void stopMotor() {
        m_intakeWheelMotor.set(0.0);
        intakeMotorRunning = false;
    }

    public boolean isIntakeRunning() {
        return intakeMotorRunning;
    }

    public void changeDirection() {
        inverted = !inverted;
        m_intakeWheelMotor.setInverted(inverted);
    }

    public boolean isIntakeLowered() {
        intakeMotorPosition = (m_lowerIntakeMotor.getSelectedSensorPosition());
        if ((intakeLowered == false) || (intakeMotorPosition == 0)) {
            if (intakeMotorPosition > Constants.IntakeConstants.intakePositionLimit) {
             m_lowerIntakeMotor.set(ControlMode.PercentOutput, 0.0);
             intakeLowered = true;
            } 
        }
         return intakeLowered;
    }

    public void lowerIntake () {
        if (intakeLowering == false) {
          m_lowerIntakeMotor.set(Constants.IntakeConstants.lowerIntakeSpeed);
            intakeLowering = true;
        }
    }

    public double getSensor() {
        return m_lowerIntakeMotor.getSelectedSensorPosition();
    }
 
    @Override 
    public void simulationPeriodic() { 
        // This method will be called once per scheduler run when in simulation 
 
    } 
 
    // Put methods for controlling this subsystem 
    // here. Call these from Commands. 
 
} 
 
 